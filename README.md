# Лабораторная работа №5: Отладĸа ĸодовой базы проеĸта на Python с помощью средств отладĸи

**Тема:** Отладĸа ĸодовой базы проеĸта на Python с помощью средств отладĸи
**Студент:** Выскворкина Мария Викторовна  
**Группа:** М8О-105БВ-25  
**Преподаватель:** Кира Лейченко 

## *Отчёт по лабораторной работе №5*

## Ошибка 1: Ошибка границы цикла (off-by-one)
Место: simulation.py, метод run_simulation, строка 31

Симптом:
Симуляция выполняется на 1 шаг меньше, чем указано в steps.

Как воспроизвести:
Запустить симуляцию с steps=20, seed=52.

Отладка:
Установлен breakpoint на строку с range. В отладчике видно, что steps=20, но цикл выполняется 19 раз.

Причина:
Использован range(steps) вместо range(1, steps+1).

Исправление:
Заменено на range(1, steps+1).

Проверка:
После исправления симуляция выполняется 20 шагов.

Доказательства:
- [error1_1](./foto/error1_1.jpg)
- [error1_2](./foto/error1_2.jpg)

## Ошибка 2: Перепутанные аргументы в конструкторе Book
Место: book.py, класс Book, метод __init__, строки 2-8

Симптом:
При создании книги, название и автор хранятся неправильно. В поле title попадает автор, в поле author - название книги. Это приводит к некорректной работе поиска по автору и названию.

Как воспроизвести:
from book import Book
book = Book("Война и мир", "Лев Толстой", 1869, "Роман", "123-456-789")
print(f"book.title = '{book.title}'")  # Выведет: 'Лев Толстой' (ошибка!)
print(f"book.author = '{book.author}'")  # Выведет: 'Война и мир' (ошибка!)

Отладка:
Установлен breakpoint в методе __init__ на строках с присваиванием. В отладчике видно, что параметр title содержит "Война и мир", но присваивается в self.author, а параметр author содержит "Лев Толстой", но присваивается в self.title.

Причина:
В конструкторе класса Book перепутаны присваивания: self.title = author вместо self.title = title и self.author = title вместо self.author = author.

Исправление:
Было:
self.title = author
self.author = title
Стало:
self.title = title
self.author = author

Проверка:
После исправления созданная книга корректно хранит название в поле title и автора в поле author. Поиск по автору и названию работает правильно.

Доказательства:
- [error2_1](./foto/error2_1.jpg)
- [error2_2](./foto/error2_2.jpg)

## Ошибка 3: Изменение коллекции во время итерации
Место: library.py, класс Library, метод find_by_genre, строки 50-55

Симптом:
При поиске книг по жанру некоторые книги пропускаются и не проверяются. Книги нужного жанра удаляются из библиотеки вместо того, чтобы просто возвращаться в результате. В некоторых случаях может возникать

Как воспроизвести:
from library import Library
from book import Book

lib = Library()
lib.add_book(Book("Фантастика 1", "Автор", 2023, "Фантастика", "001"))
lib.add_book(Book("Детектив 1", "Автор", 2023, "Детектив", "002"))
lib.add_book(Book("Фантастика 2", "Автор", 2023, "Фантастика", "003"))

result = lib.find_by_genre("Фантастика")
print(f"Найдено книг: {len(result)}")
print(f"Книг осталось в библиотеке: {len(lib.books)}")

Отладка:
Установлен breakpoint на строке с self.books.remove_book(book). В отладчике видно, что после удаления первой книги фантастики итератор переходит к следующему индексу, но из-за изменения размера коллекции следующая книга оказывается не той, которая ожидалась. Например, при исходном списке [Фантастика1, Детектив, Фантастика2] после удаления Фантастика1 список становится [Детектив, Фантастика2], но итератор продолжает с индекса 1, пропуская Детектив и проверяя только Фантастика2.

Причина:
Итерация по коллекции self.books с одновременным удалением элементов из этой же коллекции нарушает работу внутреннего итератора Python. При изменении коллекции во время итерации индексы элементов сдвигаются, что приводит к пропуску некоторых элементов или исключению.

Исправление:
Изменить строку self.books.remove_book(book) на result.append(book).

Проверка:
После исправления метод find_by_genre корректно находит все книги указанного жанра и не изменяет коллекцию self.books во время итерации. Все книги проверяются, исключения не возникают.

Доказательства:
- [error3_1](./foto/error3_1.jpg)
- [error3_2](./foto/error3_2.jpg)

## Ошибка 4: Перепутанные аргументы при удалении книги
Место: simulation.py, класс LibrarySimulator, метод run_simulation, строка 45

Симптом:
При попытке удаления книги из библиотеки операция всегда завершается неудачей, даже если книга существует. В консоль выводится сообщение "Не удалось удалить книгу", хотя в логах видно, что программа пыталась выполнить удаление.

Как воспроизвести:
from simulation import LibrarySimulator
sim = LibrarySimulator()
sim.run_simulation(steps=10, seed=42)

Отладка:
Установлен breakpoint на строке removed = library.remove_book(book.title). В отладчике видно:
book - объект книги, например: Book('1984', 'Оруэлл', 1949)
book.title - строка "1984" (название книги)
book.isbn - строка "111-222-333" (ISBN книги)
Метод library.remove_book() вызывается с аргументом "1984" вместо "111-222-333"
Внутри collection.remove_book() происходит сравнение book.isbn == "1984", которое всегда возвращает False
Книга не находится, метод возвращает None

Причина:
Вместо передачи ISBN книги (уникального идентификатора) в метод remove_book, передается ее название (book.title). Метод remove_book ожидает либо объект Book, либо строку с ISBN, но получает строку с названием, которая не соответствует ни одному ISBN в коллекции.

Исправление:
Вместо строки removed = library.remove_book(book.title) написать removed = library.remove_book(book.isbn).

Проверка:
После исправления книги успешно удаляются из библиотеки при действии 'remove' в симуляции. В консоли появляются сообщения "Удалена книга: [название] (ISBN: [номер])" вместо "Не удалось удалить книгу".

Доказательства:
- [error4_1](./foto/error4_1.jpg)
- [error4_2](./foto/error4_2.jpg)

## Ошибка 5: Логическая ошибка в условном выражении find_by_isbn
Место: library.py, класс Library, метод find_by_isbn, строки 46-50

Симптом:
Метод find_by_isbn возвращает None даже для существующих книг, если переданный ISBN является непустой строкой. Напротив, при поиске с пустым ISBN ("") метод всегда возвращает None, независимо от наличия книги с таким ISBN в библиотеке.

Как воспроизвести:
Запустить файл main.py при seed = 52 и дождаться 16 шага.

Отладка:
Установить точку останова на строке if result or isbn:. В отладчике видно:
result содержит либо объект Book, либо None
isbn содержит строку с ISBN (например "111-222-333")
Условие if result or isbn: оценивается как:
result = <Book объект> → True → возвращает книгу
result = None, isbn = "111" → if None or "111" → if False or True → True → возвращает None
result = None, isbn = "" → if None or "" → if False or False → False → возвращает None

Причина:
Использование оператора or в условии if result or isbn: приводит к неправильной логике из-за неявного приведения типов. При поиске несуществующей книги с непустым ISBN условие всегда возвращает True (так как непустая строка isbn приводится к True), и метод возвращает None из result. Условие должно проверять только результат поиска (result), а не входной параметр (isbn).

Исправление:
Заменить условие if result or isbn: на правильную проверку if result is not None: или упростить метод до return self.indexes.find_by_isbn(isbn).

Проверка:
После исправления метод корректно возвращает объект Book для существующих ISBN и None для несуществующих. Тестовые случаи обрабатываются предсказуемо.

Доказательства:
- [error5_1](./foto/error5_1.jpg)
- [error5_2](./foto/error5_2.jpg)
- [error5_3](./foto/error5_3.jpg)

## Заключение
В ходе лабораторной работы были внесены и исправлены 5 типовых ошибок:
- Ошибка границы цикла (off-by-one)
- Изменение коллекции во время итерации
- Перепутанные аргументы
- Перепутанные параметры вызова
- Логическая ошибка в условном выражении

---
ДАЛЕЕ README С 4 ЛАБЫ
---
# Лабораторная работа №4: Симуляция библиотеки с пользовательскими коллекциями

**Тема:** Пользовательские коллекции, наследование и псевдослучайная симуляция
**Вариант:** Вариант 1 — «Библиотека»  
**Студент:** Выскворкина Мария Викторовна  
**Группа:** М8О-105БВ-25  
**Преподаватель:** Кира Лейченко  

## Описание проекта
Реализация системы управления библиотекой с пользовательскими коллекциями и псевдослучайной симуляцией событий.

## Цель работы
Разработать систему, демонстрирующую работу с пользовательскими коллекциями, наследованием классов и псевдослучайной симуляцией событий в контексте управления библиотекой.

## Структура проекта
```
LAB_4_PYTHONCHIK/
├── models/
│   ├── __init__.py
│   ├── book.py              # Класс Book
│   ├── collection.py        # Пользовательские коллекции
│   ├── library.py          # Класс Library
│   └── simulation/
│       ├── __init__.py
│       └── simulation.py   # Симулятор событий
├── main.py                  # Главный файл запуска
├── README.md               # Документация
└── .gitignore              # Игнорируемые файлы
```

## Архитектура системы

### 1. **Класс Book** (`book.py`)
- **Поля**: `title`, `author`, `year`, `genre`, `isbn`
- **Магические методы**: `__repr__`, `__str__`, `__eq__`, `__hash__`
- **Дополнительные методы**: `to_dict()`

### 2. **Пользовательские коллекции** (`collection.py`)

#### BookCollection (списковая коллекция)
- Наследует поведение списка через композицию
- **Поддерживает**: `__iter__`, `__len__`, `__getitem__`, срезы, `__contains__`
- **Методы**: `add_book()`, `remove_book()`

#### IndexDict (словарная коллекция)
- Наследует от `dict`
- Автоматическая индексация по: ISBN, автору, году
- **Поддерживает**: автоматическое обновление индексов
- **Методы поиска**: `find_by_isbn()`, `find_by_author()`, `find_by_year()`

### 3. **Класс Library** (`library.py`)
- Объединяет коллекции книг и индексов
- **Методы**:
  - `add_book()` - добавление книги
  - `remove_book()` - удаление книги
  - `find_by_*()` - поиск по различным критериям
  - `search_books()` - гибкий поиск по критериям

### 4. **Симулятор** (`simulation.py`)
- Класс `LibrarySimulator`
- Метод `run_simulation(steps=20, seed=None)`
- **8 типов случайных событий**:
  1. Добавление новой книги
  2. Удаление случайной книги
  3. Поиск по автору
  4. Поиск по году
  5. Поиск по жанру
  6. Поиск по ISBN
  7. Поиск несуществующей книги (тестирование обработки ошибок)
  8. Обновление индексов

### Настройки симуляции (в `main.py`):
```python
steps = 20      # Количество шагов симуляции
seed = 52       # Seed для воспроизводимости (None для случайной)
```

## Требования к выполнению (из задания)

### Выполненные требования:

1. **Две пользовательские коллекции**:
   - `BookCollection` - списковая коллекция через композицию
   - `IndexDict` - словарная коллекция с автоматической индексацией

2. **Поддержка коллекциями**:
   - `__iter__` - итерирование
   - `__len__` - длина
   - `__getitem__` - доступ по индексу/ключу
   - Поддержка срезов (для BookCollection)
   - Добавление и удаление элементов

3. **Логика предметной области**:
   - `IndexDict` индексирует книги по ISBN, автору и году

4. **Наследование классов**:
   - Базовый класс `dict` (для IndexDict)
   - Производные классы переопределяют поведение

5. **Магические методы**:
   - `Book`: `__repr__`, `__str__`, `__eq__`, `__hash__`
   - `BookCollection`: `__iter__`, `__len__`, `__getitem__`, `__contains__`
   - `IndexDict`: `__setitem__`, `__delitem__`

6. **Функция симуляции**:
   - `run_simulation(steps=20, seed=None)`
   - Использует `random` с поддержкой `seed`
   - Воспроизводимая последовательность событий
   - Логирование в консоль

## Пример вывода симуляции
```
=== Шаг 1 ===
Добавлена книга: Война и мир (ISBN: 123-456-789)
Всего книг в библиотеке: 1

=== Шаг 2 ===
Поиск по автору 'Толстой': найдено 1 книг
    - Война и мир (1869)
Всего книг в библиотеке: 1

=== Шаг 3 ===
Поиск несуществующей книги (ISBN: 000-000-000): не найдено
Поиск несуществующего автора 'Неизвестный Автор': найдено 0 книг
Всего книг в библиотеке: 1
```