# Лабораторная работа №5: Отладĸа ĸодовой базы проеĸта на Python с помощью средств отладĸи

**Тема:** Отладĸа ĸодовой базы проеĸта на Python с помощью средств отладĸи
**Студент:** Выскворкина Мария Викторовна  
**Группа:** М8О-105БВ-25  
**Преподаватель:** Кира Лейченко 

## *Отчёт по лабораторной работе №5*

## Ошибка 1: Ошибка границы цикла (off-by-one)
Место: simulation.py, метод run_simulation, строка 31

Симптом:
Симуляция выполняется на 1 шаг меньше, чем указано в steps.

Как воспроизвести:
Запустить симуляцию с steps=20, seed=52.

Отладка:
Установлен breakpoint на строку с range. В отладчике видно, что steps=20, но цикл выполняется 19 раз.

Причина:
Использован range(steps) вместо range(1, steps+1).

Исправление:
Заменено на range(1, steps+1).

Проверка:
После исправления симуляция выполняется 20 шагов.

Доказательства:
- [error1_1](./foto/error1_1.jpg)
- [error1_2](./foto/error1_2.jpg)

## Ошибка 2: Перепутанные аргументы в конструкторе Book
Место: book.py, класс Book, метод __init__, строки 2-8

Симптом:
При создании книги, название и автор хранятся неправильно. В поле title попадает автор, в поле author - название книги. Это приводит к некорректной работе поиска по автору и названию.

Как воспроизвести:
from book import Book
book = Book("Война и мир", "Лев Толстой", 1869, "Роман", "123-456-789")
print(f"book.title = '{book.title}'")  # Выведет: 'Лев Толстой' (ошибка!)
print(f"book.author = '{book.author}'")  # Выведет: 'Война и мир' (ошибка!)

Отладка:
Установлен breakpoint в методе __init__ на строках с присваиванием. В отладчике видно, что параметр title содержит "Война и мир", но присваивается в self.author, а параметр author содержит "Лев Толстой", но присваивается в self.title.

Причина:
В конструкторе класса Book перепутаны присваивания: self.title = author вместо self.title = title и self.author = title вместо self.author = author.

Исправление:
Было:
self.title = author
self.author = title
Стало:
self.title = title
self.author = author

Проверка:
После исправления созданная книга корректно хранит название в поле title и автора в поле author. Поиск по автору и названию работает правильно.

Доказательства:
- [error2_1](./foto/error2_1.jpg)
- [error2_2](./foto/error2_2.jpg)

## Ошибка 3: Изменение коллекции во время итерации
Место: library.py, класс Library, метод find_by_genre, строки 50-55

Симптом:
При поиске книг по жанру некоторые книги пропускаются и не проверяются. Книги нужного жанра удаляются из библиотеки вместо того, чтобы просто возвращаться в результате. В некоторых случаях может возникать

Как воспроизвести:
from library import Library
from book import Book

lib = Library()
lib.add_book(Book("Фантастика 1", "Автор", 2023, "Фантастика", "001"))
lib.add_book(Book("Детектив 1", "Автор", 2023, "Детектив", "002"))
lib.add_book(Book("Фантастика 2", "Автор", 2023, "Фантастика", "003"))

result = lib.find_by_genre("Фантастика")
print(f"Найдено книг: {len(result)}")
print(f"Книг осталось в библиотеке: {len(lib.books)}")

Отладка:
Установлен breakpoint на строке с self.books.remove_book(book). В отладчике видно, что после удаления первой книги фантастики итератор переходит к следующему индексу, но из-за изменения размера коллекции следующая книга оказывается не той, которая ожидалась. Например, при исходном списке [Фантастика1, Детектив, Фантастика2] после удаления Фантастика1 список становится [Детектив, Фантастика2], но итератор продолжает с индекса 1, пропуская Детектив и проверяя только Фантастика2.

Причина:
Итерация по коллекции self.books с одновременным удалением элементов из этой же коллекции нарушает работу внутреннего итератора Python. При изменении коллекции во время итерации индексы элементов сдвигаются, что приводит к пропуску некоторых элементов или исключению.

Исправление:
Изменить строку self.books.remove_book(book) на result.append(book).

Проверка:
После исправления метод find_by_genre корректно находит все книги указанного жанра и не изменяет коллекцию self.books во время итерации. Все книги проверяются, исключения не возникают.

Доказательства:
- [error3_1](./foto/error3_1.jpg)
- [error3_2](./foto/error3_2.jpg)

## Ошибка 4: Перепутанные аргументы при удалении книги
Место: simulation.py, класс LibrarySimulator, метод run_simulation, строка 45

Симптом:
При попытке удаления книги из библиотеки операция всегда завершается неудачей, даже если книга существует. В консоль выводится сообщение "Не удалось удалить книгу", хотя в логах видно, что программа пыталась выполнить удаление.

Как воспроизвести:
from simulation import LibrarySimulator
sim = LibrarySimulator()
sim.run_simulation(steps=10, seed=42)

Отладка:
Установлен breakpoint на строке removed = library.remove_book(book.title). В отладчике видно:
book - объект книги, например: Book('1984', 'Оруэлл', 1949)
book.title - строка "1984" (название книги)
book.isbn - строка "111-222-333" (ISBN книги)
Метод library.remove_book() вызывается с аргументом "1984" вместо "111-222-333"
Внутри collection.remove_book() происходит сравнение book.isbn == "1984", которое всегда возвращает False
Книга не находится, метод возвращает None

Причина:
Вместо передачи ISBN книги (уникального идентификатора) в метод remove_book, передается ее название (book.title). Метод remove_book ожидает либо объект Book, либо строку с ISBN, но получает строку с названием, которая не соответствует ни одному ISBN в коллекции.

Исправление:
Вместо строки removed = library.remove_book(book.title) написать removed = library.remove_book(book.isbn).

Проверка:
После исправления книги успешно удаляются из библиотеки при действии 'remove' в симуляции. В консоли появляются сообщения "Удалена книга: [название] (ISBN: [номер])" вместо "Не удалось удалить книгу".

Доказательства:
- [error4_1](./foto/error4_1.jpg)
- [error4_2](./foto/error4_2.jpg)

## Ошибка 5: Логическая ошибка в условном выражении find_by_isbn
Место: library.py, класс Library, метод find_by_isbn, строки 46-50

Симптом:
Метод find_by_isbn возвращает None даже для существующих книг, если переданный ISBN является непустой строкой. Напротив, при поиске с пустым ISBN ("") метод всегда возвращает None, независимо от наличия книги с таким ISBN в библиотеке.

Как воспроизвести:
Запустить файл main.py при seed = 52 и дождаться 16 шага.

Отладка:
Установить точку останова на строке if result or isbn:. В отладчике видно:
result содержит либо объект Book, либо None
isbn содержит строку с ISBN (например "111-222-333")
Условие if result or isbn: оценивается как:
result = <Book объект> → True → возвращает книгу
result = None, isbn = "111" → if None or "111" → if False or True → True → возвращает None
result = None, isbn = "" → if None or "" → if False or False → False → возвращает None

Причина:
Использование оператора or в условии if result or isbn: приводит к неправильной логике из-за неявного приведения типов. При поиске несуществующей книги с непустым ISBN условие всегда возвращает True (так как непустая строка isbn приводится к True), и метод возвращает None из result. Условие должно проверять только результат поиска (result), а не входной параметр (isbn).

Исправление:
Заменить условие if result or isbn: на правильную проверку if result is not None: или упростить метод до return self.indexes.find_by_isbn(isbn).

Проверка:
После исправления метод корректно возвращает объект Book для существующих ISBN и None для несуществующих. Тестовые случаи обрабатываются предсказуемо.

Доказательства:
- [error5_1](./foto/error5_1.jpg)
- [error5_2](./foto/error5_2.jpg)
- [error5_3](./foto/error5_3.jpg)

## Заключение
В ходе лабораторной работы были внесены и исправлены 5 типовых ошибок:
- Ошибка границы цикла (off-by-one)
- Изменение коллекции во время итерации
- Перепутанные аргументы
- Перепутанные параметры вызова
- Логическая ошибка в условном выражении